# J04

本仓库提供了一个基于Java Swing的简单游戏引擎，并演示了如何使用多线程并发来优化游戏性能。本项目适合用于学习游戏引擎原理和多线程编程。


## 游戏逻辑说明

这是一个躲避游戏：用户玩家（绿色方块）使用WASD或方向键控制移动，需要躲避所有AI玩家（蓝绿色方块）。游戏开始时会有30个AI玩家，每隔1秒会新增一个。AI玩家会随机移动，当彼此距离小于80像素时会互相避开，碰到屏幕边界会反弹。如果用户玩家与任何AI玩家碰撞，游戏立即结束并显示"GAME OVER"。游戏分辨率为1920x1080。


## 并行处理优化

随着AI玩家数量不断增加，游戏需要处理的物理计算和避障计算呈线性增长。如果使用串行处理，当AI玩家数量达到50、100甚至更多时，每一帧的计算时间会急剧增加，导致游戏帧率下降。本版本在上一版本的基础上，增加了两个关键的并行处理模块：1) **并行物理计算**（`updatePhysics()`）：使用`ExecutorService`创建线程池，将物理组件按批次分配给不同线程，每个线程独立更新自己批次内的物理组件（位置、速度、边界碰撞检测），使用`Future`等待所有线程完成；2) **自适应并行避障计算**（`handleAIPlayerAvoidance()`）：当AI玩家数量小于10个时使用串行处理避免线程开销，大于等于10个时使用并行处理，将AI玩家分批处理避障计算。在并行处理中需要注意线程安全：确保每个物理组件只被一个线程更新，`Vector2`对象返回副本避免共享可变对象，使用`Future.get()`确保所有线程完成后再继续。


## 作业要求

### 任务

请分析你自己游戏中的性能问题，并参考本项目的并行处理实现，为你的游戏添加多线程并行优化。

### 要求

1. **性能分析**：
   - 找出你游戏中计算量大的部分
   - 分析哪些计算可以并行化（独立计算，不依赖其他计算结果）
   - 估算并行化后可能带来的性能提升

2. **实现并行处理**：
   - 参考本项目中使用 `ExecutorService` 的实现方式
   - 使用线程池管理线程，而不是直接创建 `Thread` 对象
   - 合理划分批次大小，平衡线程开销和并行收益
   - 注意线程安全问题，确保共享数据的一致性

3. **性能测试**：
   - 对比并行化前后的帧率或计算时间
   - 分析并行化的效果（是否提升了性能？提升了多少？）

### ⚠️ 重要提醒

**你必须手工编写并行处理的代码因为考试会考！**

### 提交要求

- 在代码中清晰标注你实现的并行处理部分
- 在README中说明：
  - 你识别了哪些性能瓶颈
  - 如何实现并行化
  - 并行化前后的性能对比
- 游戏录屏发小破站

